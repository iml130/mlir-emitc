<!-- Autogenerated by mlir-tblgen; don't manually edit -->
# 'emitc' Dialect

[TOC]

## Type constraint definition

### An opaque type
An opaque data type of which the value gets emitted as is.

Examples:

```mlir
!emitc.opaque<"int">
!emitc.opaque<"float *">
!emitc.opaque<"std::vector<std::string>">
```

## Operation definition

### `emitc.call` (::mlir::emitc::CallOp)

call operation


Syntax:

```
operation ::= `emitc.call` $callee `(` $operands `)` attr-dict `:` functional-type($operands, results)
```

The "call" operation represents a C++ function call. The call allows
specifying order of operands and attributes in the call as follows:

- integer value of index type refers to an operand;
- attribute which will get lowered to constant value in call;

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`callee` | ::mlir::StringAttr | string attribute
`args` | ::mlir::ArrayAttr | array attribute
`template_args` | ::mlir::ArrayAttr | array attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`operands` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | any type

### `emitc.for` (::mlir::emitc::ForOp)

for operation

The "emitc.for" operation represents a loop taking 3 SSA value as operands
that represent the lower bound, upper bound and step respectively.  The
operation defines an SSA value for its induction variable. It has one
region capturing the loop body. The induction variable is represented as an
argument of this region. This SSA value always has type index, which is the
size of the machine word. The step is a value of type index, required to be
positive.
The lower and upper bounds specify a half-open range: the range includes
the lower bound but does not include the upper bound.

The body region must contain exactly one block that terminates with
"emitc.yield". Calling ForOp::build will create such a region and insert
the terminator implicitly if none is defined, so will the parsing even in
cases when it is absent from the custom format. For example:

```mlir
emitc.for %iv = %lb to %ub step %step {
  ... // body
}
```

`emitc.for` can also operate on loop-carried variables and returns the final
values after loop termination. The initial values of the variables are
passed as additional SSA operands to the "emitc.for" following the 3 loop
control SSA values mentioned above (lower bound, upper bound and step). The
operation region has equivalent arguments for each variable representing
the value of the variable at the current iteration.

The region must terminate with a "emitc.yield" that passes all the current
iteration variables to the next iteration, or to the "emitc.for" result, if
at the last iteration. Note, that when the loop-carried variables are
present, calling ForOp::build will not insert the terminator implicitly.
The caller must insert "emitc.yield" in that case.

"emitc.for" results hold the final values after the last iteration.
For example, to sum-reduce a memref:

```mlir
func @reduce(%buffer: memref<1024xf32>, %lb: index,
             %ub: index, %step: index) -> (f32) {
  // Initial sum set to 0.
  %sum_0 = constant 0.0 : f32
  // iter_args binds initial values to the loop's region arguments.
  %sum = emitc.for %iv = %lb to %ub step %step
      iter_args(%sum_iter = %sum_0) -> (f32) {
    %t = load %buffer[%iv] : memref<1024xf32>
    %sum_next = addf %sum_iter, %t : f32
    // Yield current iteration sum to next iteration %sum_iter or to %sum
    // if final iteration.
    emitc.yield %sum_next : f32
  }
  return %sum : f32
}
```

If the "emitc.for" defines any values, a yield must be explicitly present.
The number and types of the "emitc.for" results must match the initial
values in the "iter_args" binding and the yield operands.

Another example with a nested "emitc.if" (see "emitc.if" for details) to
perform conditional reduction:

```mlir
func @conditional_reduce(%buffer: memref<1024xf32>, %lb: index,
                         %ub: index, %step: index) -> (f32) {
  %sum_0 = constant 0.0 : f32
  %c0 = constant 0.0 : f32
  %sum = emitc.for %iv = %lb to %ub step %step
      iter_args(%sum_iter = %sum_0) -> (f32) {
    %t = load %buffer[%iv] : memref<1024xf32>
    %cond = cmpf "ugt", %t, %c0 : f32
    %sum_next = emitc.if %cond -> (f32) {
      %new_sum = addf %sum_iter, %t : f32
      emitc.yield %new_sum : f32
    } else {
      emitc.yield %sum_iter : f32
    }
    emitc.yield %sum_next : f32
  }
  return %sum : f32
}
```

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`lowerBound` | index
`upperBound` | index
`step` | index
`initArgs` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
`results` | any type

### `emitc.if` (::mlir::emitc::IfOp)

if-then-else operation

The `emitc.if` operation represents an if-then-else construct for
conditionally executing two regions of code. The operand to an if operation
is a boolean value. For example:

```mlir
emitc.if %b  {
  ...
} else {
  ...
}
```

`emitc.if` may also return results that are defined in its regions. The
values defined are determined by which execution path is taken.

Example:

```mlir
%x, %y = emitc.if %b -> (f32, f32) {
  %x_true = ...
  %y_true = ...
  emitc.yield %x_true, %y_true : f32, f32
} else {
  %x_false = ...
  %y_false = ...
  emitc.yield %x_false, %y_false : f32, f32
}
```

`emitc.if` regions are always terminated with "emitc.yield". If "emitc.if"
defines no values, the "emitc.yield" can be left out, and will be inserted
implicitly. Otherwise, it must be explicit.
Also, if "emitc.if" defines one or more values, the 'else' block cannot be
omitted.

Example:

```mlir
emitc.if %b  {
  ...
}
```

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`condition` | 1-bit signless integer

#### Results:

| Result | Description |
| :----: | ----------- |
`results` | any type

### `emitc.yield` (::mlir::emitc::YieldOp)

loop yield and termination operation

"emitc.yield" yields an SSA value from the EmitC dialect op region and
terminates the regions. The semantics of how the values are yielded is
defined by the parent operation.
If "emitc.yield" has any operands, the operands must match the parent
operation's results.
If the parent operation defines no values, then the "emitc.yield" may be
left out in the custom syntax and the builders will insert one implicitly.
Otherwise, it has to be present in the syntax to indicate which values are
yielded.

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`results` | any type

## Type definition

### `OpaqueType` (OpaqueType)

An opaque type

An opaque data type of which the value gets emitted as is.

Examples:

```mlir
!emitc.opaque<"int">
!emitc.opaque<"float *">
!emitc.opaque<"std::vector<std::string>">
```

#### Type parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| value | `::llvm::StringRef` | the opaque value |

